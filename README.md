# 设计模式

## 单例模式

### 应用场景

    单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并
    提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。
    例如，国家主席、公司 CEO、部门经理等。在 J2EE 标准中，ServletContext、
    ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext；数据库的连接
    池也都是单例形式
    
> 饿汉式单例  

    饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线
    程还没出现以前就是实例化了，不可能存在访问安全问题。
    优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。
    缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅
    坑不拉屎。
    Spring 中 IOC 容器 ApplicationContext 本身就是典型的饿汉式单例  
    
> 懒汉式单例

    被外部类调用的时候内部类才会加载
    DoubleCheck机制实现线程安全
    
> 内部类实现单例

    内部类不会在其外部类被加载的同时被加载，内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题，同事避免了
    内存浪费
    
> 注册式单例

    注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标
    识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记    
    
            
>> 枚举登记

    枚举类型其实通过类名和 Class 对象类找到一个唯一的枚举对象，可以避免序列化破坏单例
    
    在newInstance()方法中做了强制性的判断，如果修饰符是 Modifier.ENUM 枚举类型，
    直接抛出异常,避免了反射破坏单例
    
> ThreadLocal线程单例

    ThreadLocal 不能保证其创建的对象是全局唯一，但是能保证在单个线程中是唯一的，天生的线程安全
    
    ThreadLocal 将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象，实际上是以
    空间换时间来实现线程间隔离的
    
> 小结

    单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用        
    
    
##  原型模式    

### 使用場景

>  1、类初始化消耗资源较多。

>  2、new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等） 

> 3、构造函数比较复杂。

> 4、循环体中生产大量对象时   

>* 淺克隆

    复制的不是值，而是引用的地址。这 样 的 话 ， 如 果 我 们 修 改 任 意 一 个 对 象 中 的 属 性 值 ，
     concretePrototype 和 concretePrototypeCone 的 hobbies 值都会改变。这就是我们常说的浅克隆。只是完整
    复制了值类型数据，没有赋值引用对象。换言之，所有的引用对象仍然指向原来的对象，
    显然不是我们想要的结果